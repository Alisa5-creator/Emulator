import tkinter as tk
from tkinter import scrolledtext
import re
from datetime import datetime
import os

class TerminalEmulator:
    def __init__(self, root, script_path=None, vfs_path=None):
        self.root = root
        self.vfs_path = vfs_path or os.getcwd()
        self.root.title("VFS Terminal Emulator")

        self.vfs = None
        
        self.script_path = script_path
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.output_area = scrolledtext.ScrolledText(main_frame, height=20)
        self.output_area.pack(fill=tk.BOTH, expand=True)
        self.output_area.config(state=tk.DISABLED)
        
        input_frame = tk.Frame(main_frame)
        input_frame.pack(fill=tk.X, pady=(5, 0))

        os.environ["DATE"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        os.environ["PWD"] = "/"
        os.environ["USER"] = os.getlogin() if hasattr(os, 'getlogin') else "user"
        os.environ["HOME"] = "/"
        
        self.prompt_text = self.parse_env_var("$USER@VFS")
        self.prompt_label = tk.Label(input_frame, text=self.prompt_text)
        self.prompt_label.pack(side=tk.LEFT)
        
        self.input_field = tk.Entry(input_frame, relief=tk.FLAT)
        self.input_field.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))
        self.input_field.focus()
        
        self.input_field.bind('<Return>', self.process_command)
       
        self.print_output("")
    
    def repl(self, match):
        name = match.group(1)
        return os.environ.get(name, '')
    def startup_script(self):
    if not self.script_path or not os.path.exists(self.script_path):
        self.print_output(f"Ошибка: скрипт '{self.script_path}' не найден")
        return
    
    self.print_output(f"Выполнение скрипта '{self.script_path}'")
    
    try:
        with open(self.script_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            for line_num, line in enumerate(lines, 1):
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                
                self.print_output(f"{self.prompt_text}> {line}")
                try:
                    self.command_reader(line)
                except Exception as e:
                    self.print_output(f"Строка {line_num}: ошибка - {str(e)}")
                    self.print_output("Скрипт остановлен из-за ошибки")
                    return
    except Exception as e:
        self.print_output(f'Ошибка чтения скрипта: {str(e)}')
    
    self.print_output("Завершение выполнения скрипта")
            
    def parse_env_var(self, command):
        pattern = r'\$(\w+)'
        return re.sub(pattern, self.repl, command)
    
    def print_output(self, text):
        self.output_area.config(state=tk.NORMAL)
        self.output_area.insert(tk.END, text + "\n")
        self.output_area.config(state=tk.DISABLED)
        self.output_area.see(tk.END)
    
    def cmd_ls(self, args):
        self.print_output(f"ls: {' '.join(args) if args else ''}")
        self.print_output("bin/ documents/ config/ temp/")
    
    def cmd_cd(self, args):
        target = args[0] if args else "/"
        self.print_output(f"cd: {target}")
    
    def cmd_exit(self, args):
        self.root.quit()
    
    def command_reader(self, command):
        parsed = self.parse_env_var(command)
        cmd_parts = parsed.split()
        if not cmd_parts:
            return
        
        cmd = cmd_parts[0]
        args = cmd_parts[1:]
        
        if cmd == "exit":
            self.cmd_exit(args)
        elif cmd == "ls":
            self.cmd_ls(args)
        elif cmd == "cd":
            self.cmd_cd(args)
        else:
            self.print_output(f"Ошибка: неизвестная команда '{cmd}'")
    
    def process_command(self, event):
        command = self.input_field.get().strip()
        self.input_field.delete(0, tk.END)
        if not command:
            return
        
        self.print_output(f"{self.prompt_text}> {command}")
        try:
            self.command_reader(command)
        except Exception as e:
            self.print_output(f"Ошибка: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    root.geometry("800x600") 
    terminal = TerminalEmulator(root)
    root.mainloop()
